<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title> Cool Game</title>
<style>
  body { font-family: system-ui, sans-serif; background:#111; color:#eee; display:flex; flex-direction:column; align-items:center; padding:16px; }
  .board-wrap {
    position:relative;
    display:grid;
    grid-template-areas:
      ". top ."
      "left board right"
      ". bottom .";
    grid-template-columns:auto auto auto;
    grid-template-rows:auto auto auto;
    align-items:center; justify-items:center; gap:10px; margin:20px 0;
  }
  .grid { 
    display:grid; 
    gap:4px;
    background:#222; padding:8px; border-radius:8px; grid-area:board; overflow:hidden; 
  }
  .cell { width:50px; height:50px; display:flex; align-items:center; justify-content:center; border-radius:6px; font-weight:700; box-shadow:inset 0 -2px rgba(0,0,0,0.3);
    transition: transform 0.45s cubic-bezier(.42,1.2,.44,1.01), opacity 0.22s cubic-bezier(.42,1.2,.44,1.01); cursor:pointer; }
  .cell.black { background:#444; color:#fff; }
  .cell.red { background:#d73a3a; color:#fff; }
  .cell.blue { background:#2b79d6; color:#fff; }
  .cell.yellow { background:#e8c03a; color:#222; }
  .cell.immovable { background:linear-gradient(135deg,#333,#111); border:2px solid #000; color:#7e4242; }
  .cell.immovable.red { color:#ff2600; background:linear-gradient(135deg,#000000 55%,#111); border-color:#d73a3a;}
  .cell.immovable.blue { color:#0004ff; background:linear-gradient(135deg,#000000 55%,#111); border-color:#2b79d6; }
  .cell.immovable.yellow { color:#fffb00; background:linear-gradient(135deg,#000000 55%,#111); border-color:#e8c03a; }

  .edge-buttons { display:flex; gap:4px; }
  .edge-buttons.column { flex-direction:column; }
  .edge-buttons button { width:50px; height:28px; font-size:12px; cursor:pointer; background:#2a2a2a; color:#eee; border:1px solid #444; border-radius:4px; }
  .edge-buttons.column button { width:28px; height:50px; }

  #top-edges { grid-area: top; }
  #bottom-edges { grid-area: bottom; }
  #left-edges { grid-area: left; }
  #right-edges { grid-area: right; }

  .controls { display:flex; gap:10px; margin-top:10px; }
  .controls button.active { background:#666; color:#fff; border-color:#888; }

  button:disabled { opacity:.4; cursor:not-allowed; }

  .status { background:#161616; padding:10px; border-radius:8px; margin-top:16px; width:340px; }
  .info { font-size:14px; margin-bottom:6px; }
  .block-legend { margin:4px 0 0 0; font-size:13px; }
  .block-legend .swatch {
    display:inline-block; width:20px; height:20px; vertical-align:middle; border-radius:5px; margin:0 3px 0 0;
    background:linear-gradient(135deg,#333,#111);
    border:2px solid #000;
    position:relative; top:2px;
  }
  .block-legend .swatch.red { background:linear-gradient(135deg,#d73a3a 55%,#111); border-color:#d73a3a;}
  .block-legend .swatch.blue { background:linear-gradient(135deg,#2b79d6 55%,#111); border-color:#2b79d6;}
  .block-legend .swatch.yellow { background:linear-gradient(135deg,#e8c03a 55%,#111); border-color:#e8c03a;}

  /* Color badge styles (same as before) */
  .player-color-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 15px auto;
    gap: 18px;
  }
  .player-badge-outer {
    width: 62px; height: 62px;
    border-radius: 50%;
    box-shadow: 0 0 16px 1px #000a;
    display: flex; align-items: center; justify-content: center;
    position: relative;
    background: #222;
    margin-right: 6px;
  }
  .player-badge-inner {
    width: 45px; height: 45px;
    border-radius: 50%;
    display: flex;
    align-items: center; justify-content: center;
    font-size: 1.7em;
    font-weight: bold;
    box-shadow: 0 0 0 3px #fff4 inset;
    border: 3px solid #fff6;
    transition: box-shadow 0.3s;
  }
  .player-badge-inner.red {
    background: radial-gradient(circle at 60% 30%, #ff8484 0%, #d73a3a 70%, #a21515 100%);
    color: #fff;
    text-shadow: 0 1px 2px #800, 0 0 3px #fff7;
    box-shadow: 0 0 20px 2px #d73a3a8c, 0 0 0 3px #fff4 inset;
    border-color: #d73a3a;
    animation: badge-glow-red 1.7s infinite alternate;
  }
  .player-badge-inner.blue {
    background: radial-gradient(circle at 60% 30%, #8bb9f9 0%, #2b79d6 70%, #18427f 100%);
    color: #fff;
    text-shadow: 0 1px 2px #024, 0 0 3px #fff7;
    box-shadow: 0 0 20px 2px #2b79d67a, 0 0 0 3px #fff4 inset;
    border-color: #2b79d6;
    animation: badge-glow-blue 1.7s infinite alternate;
  }
  .player-badge-inner.yellow {
    background: radial-gradient(circle at 60% 30%, #fff4a8 0%, #e8c03a 70%, #9e8700 100%);
    color: #222;
    text-shadow: 0 1px 2px #b28a00, 0 0 3px #fff7;
    box-shadow: 0 0 20px 2px #e8c03a82, 0 0 0 3px #fff4 inset;
    border-color: #e8c03a;
    animation: badge-glow-yellow 1.7s infinite alternate;
  }
  @keyframes badge-glow-red {
    0% { box-shadow: 0 0 8px 1px #d73a3a33, 0 0 0 3px #fff4 inset;}
    100% { box-shadow: 0 0 32px 6px #ff6a6aa7, 0 0 0 7px #fff4 inset;}
  }
  @keyframes badge-glow-blue {
    0% { box-shadow: 0 0 8px 1px #2b79d633, 0 0 0 3px #fff4 inset;}
    100% { box-shadow: 0 0 32px 6px #7bd0ffb0, 0 0 0 7px #fff4 inset;}
  }
  @keyframes badge-glow-yellow {
    0% { box-shadow: 0 0 8px 1px #e8c03a33, 0 0 0 3px #fff4 inset;}
    100% { box-shadow: 0 0 32px 6px #ffe16ab0, 0 0 0 7px #fff4 inset;}
  }
  .player-color-label {
    font-size: 1.22em;
    font-weight: bold;
    letter-spacing: 1px;
    color: #fff;
    text-shadow: 0 1px 3px #000a;
  }
</style>
</head>
<body>
<div class="player-color-indicator" id="playerColorIndicator"></div>
<h1 id="gameTitle">Push-Colors Game</h1>
<div class="board-wrap">
  <div id="top-edges" class="edge-buttons"></div>
  <div id="left-edges" class="edge-buttons column"></div>
  <div id="grid" class="grid"></div>
  <div id="right-edges" class="edge-buttons column"></div>
  <div id="bottom-edges" class="edge-buttons"></div>
</div>
<div class="controls">
  <button id="mode-push" class="active">Push Mode</button>
  <button id="mode-block">Block Mode</button>
  <button id="restart">Restart</button>
</div>
<div class="status">
  <div class="info"><strong>Turn:</strong> <span id="turnLabel">—</span></div>
  <div class="info"><strong>Current Mode:</strong> <span id="modeLabel">Push</span></div>
  <div class="info"><strong>Player color:</strong> <span id="playerColor">—</span></div>
  <div class="info"><strong>AI1 color:</strong> <span id="ai1Color">—</span></div>
  <div class="info"><strong>AI2 color:</strong> <span id="ai2Color">—</span></div>
  <div id="counts"></div>
  <div style="margin-top:12px;" id="message"></div>
  <div class="block-legend">
    <span class="swatch"></span> = AI immovable block &nbsp;&nbsp;
    <span class="swatch red"></span> <span class="swatch blue"></span> <span class="swatch yellow"></span> = Block color matches owner
  </div>
</div>
<script>
(() => {
  // Instead of constants, these become variables
  let ROWS = 7, COLS = 7;
  const COLORS=['red','blue','yellow'];
  const COLOR_LABELS = { red: "Red", blue: "Blue", yellow: "Yellow"};
  const COLOR_EMOJIS = { red: "🟥", blue: "🟦", yellow: "🟨" };
  const BLACK='black', IMMOVABLE='immovable';

  const gridEl=document.getElementById('grid');
  const topEdges=document.getElementById('top-edges');
  const bottomEdges=document.getElementById('bottom-edges');
  const leftEdges=document.getElementById('left-edges');
  const rightEdges=document.getElementById('right-edges');
  const turnLabel=document.getElementById('turnLabel');
  const countsEl=document.getElementById('counts');
  const messageEl=document.getElementById('message');
  const playerColorEl=document.getElementById('playerColor');
  const ai1ColorEl=document.getElementById('ai1Color');
  const ai2ColorEl=document.getElementById('ai2Color');
  const restartBtn=document.getElementById('restart');
  const modePushBtn=document.getElementById('mode-push');
  const modeBlockBtn=document.getElementById('mode-block');
  const modeLabel=document.getElementById('modeLabel');
  const playerColorIndicator=document.getElementById('playerColorIndicator');
  const gameTitle=document.getElementById('gameTitle');

  let board=[], players=[], turnIdx=0, mode='push';
  let immovablePositions={}, blockInventory={}, immovableColors={};
  let colors={};

  function randShuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

  function initBoard(){
    board=Array.from({length:ROWS},()=>Array(COLS).fill(null));
    board[0][0]=BLACK; board[0][COLS-1]=BLACK; board[ROWS-1][0]=BLACK; board[ROWS-1][COLS-1]=BLACK;
    let pool=[]; COLORS.forEach(c=>{for(let i=0;i<Math.ceil((ROWS*COLS-4)/COLORS.length);i++) pool.push(c);});
    randShuffle(pool); let idx=0;
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(board[r][c]===null) board[r][c]=pool[idx++];
    immovablePositions={}; blockInventory={}; immovableColors={};
    players.forEach(p=>{blockInventory[p]=true; immovablePositions[p]=null; immovableColors[p]=null;});
  }

  function renderGrid(){
    // Update grid style
    gridEl.style.gridTemplateColumns = `repeat(${COLS}, 50px)`;
    gridEl.style.gridTemplateRows = `repeat(${ROWS}, 50px)`;
    gameTitle.textContent = `${COLS}×${ROWS} Push-Colors Game`;
    gridEl.innerHTML='';
    let posToOwner = {};
    Object.keys(immovablePositions).forEach(owner => {
      const pos = immovablePositions[owner];
      if(pos) posToOwner[pos[0]+','+pos[1]] = owner;
    });

    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const div=document.createElement('div');
      div.className='cell';
      const val=board[r][c];

      div.classList.add(val);

      if(val === IMMOVABLE) {
        let owner = posToOwner[r+','+c];
        if(owner) {
          const color = immovableColors[owner] || 'black';
          div.classList.add(color);
        }
        div.textContent = '■';
      } else {
        div.textContent = '';
      }
      div.onclick = () => {
        if(currentPlayer() === 'player' && mode === 'block'){
          handleBlockClick(r, c);
        }
      };

      gridEl.appendChild(div);
    }
    updateCounts();
  }

  function setupEdgeButtons(){
    topEdges.innerHTML=''; bottomEdges.innerHTML=''; leftEdges.innerHTML=''; rightEdges.innerHTML='';
    for(let c=0;c<COLS;c++){
      let t=document.createElement('button'); t.textContent='↓'; t.onclick=()=>playerPush('col',c,1); topEdges.appendChild(t);
      let b=document.createElement('button'); b.textContent='↑'; b.onclick=()=>playerPush('col',c,-1); bottomEdges.appendChild(b);
    }
    for(let r=0;r<ROWS;r++){
      let l=document.createElement('button'); l.textContent='→'; l.onclick=()=>playerPush('row',r,1); leftEdges.appendChild(l);
      let rt=document.createElement('button'); rt.textContent='←'; rt.onclick=()=>playerPush('row',r,-1); rightEdges.appendChild(rt);
    }
  }

  function handleBlockClick(r,c){
    const me = 'player';
    const val = board[r][c];
    const pos = immovablePositions[me];

    if(val === BLACK && blockInventory[me]){
      board[r][c] = IMMOVABLE;
      immovablePositions[me] = [r,c];
      blockInventory[me] = false;
      immovableColors[me] = colors[me];
      renderGrid(); endTurn();
      return;
    }

    if(val === IMMOVABLE && pos && pos[0]===r && pos[1]===c){
      board[r][c] = BLACK;
      immovablePositions[me] = null;
      blockInventory[me] = true;
      immovableColors[me] = null;
      renderGrid(); endTurn();
      return;
    }
  }

  function playerPush(type,idx,dir){
    if(currentPlayer() !== 'player' || mode !== 'push') return;
    pushWithAnimation(type,idx,dir,(success)=>{
      if(success) {
        endTurn();
      } else {
        messageEl.textContent = "You can't push there! Try another move.";
      }
    });
  }

  function attemptPush(type,idx,dir){
    let path=[]; if(type==='row') for(let c=0;c<COLS;c++) path.push([idx,c]);
    else for(let r=0;r<ROWS;r++) path.push([r,idx]);
    if(path.some(([r,c])=>board[r][c]===IMMOVABLE)) return false;
    if(type==='row'){ if(dir===1){ for(let c=COLS-1;c>0;c--) board[idx][c]=board[idx][c-1]; board[idx][0]=BLACK; }
      else { for(let c=0;c<COLS-1;c++) board[idx][c]=board[idx][c+1]; board[idx][COLS-1]=BLACK; } }
    else { if(dir===1){ for(let r=ROWS-1;r>0;r--) board[r][idx]=board[r-1][idx]; board[0][idx]=BLACK; }
      else { for(let r=0;r<ROWS-1;r++) board[r][idx]=board[r+1][idx]; board[ROWS-1][idx]=BLACK; } }
    return true;
  }

  function pushWithAnimation(type,idx,dir,callback){
    renderGrid();

    let path=[]; if(type==='row') for(let c=0;c<COLS;c++) path.push([idx,c]);
    else for(let r=0;r<ROWS;r++) path.push([r,idx]);
    if(path.some(([r,c])=>board[r][c]===IMMOVABLE)){
      path.forEach(([r,c])=>{
        const cell=gridEl.children[r*COLS+c];
        if(type==='row') {
          cell.style.transition = "transform 0.32s cubic-bezier(.7,-0.5,.3,1.7)";
          cell.style.transform=`translateX(${dir*10}px)`;
        } else {
          cell.style.transition = "transform 0.32s cubic-bezier(.7,-0.5,.3,1.7)";
          cell.style.transform=`translateY(${dir*10}px)`;
        }
      });
      setTimeout(()=>{ 
        path.forEach(([r,c])=>{
          const cell=gridEl.children[r*COLS+c];
          cell.style.transform="";
        });
        if(callback) callback(false);
      },330);
      return;
    }

    let edgeIdx = type==='row' ? (dir===1?COLS-1:0) : (dir===1?ROWS-1:0);
    let edgeCell;
    if(type==='row') edgeCell = gridEl.children[idx*COLS+edgeIdx];
    else edgeCell = gridEl.children[edgeIdx*COLS+idx];
    edgeCell.style.transition = 'opacity 0.22s cubic-bezier(.42,1.2,.44,1.01)';
    edgeCell.style.opacity = '0';

    path.forEach(([r,c])=>{
      const cell=gridEl.children[r*COLS+c];
      if(type==='row') {
        cell.style.transition = "transform 0.45s cubic-bezier(.42,1.2,.44,1.01)";
        cell.style.transform=`translateX(${dir*55}px)`;
      } else {
        cell.style.transition = "transform 0.45s cubic-bezier(.42,1.2,.44,1.01)";
        cell.style.transform=`translateY(${dir*55}px)`;
      }
    });

    setTimeout(()=>{
      attemptPush(type,idx,dir);
      renderGrid();
      if(callback) callback(true);
    },470);
  }

  function endTurn(){
    updateCounts(); if(checkWin()) return;
    turnIdx=(turnIdx+1)%players.length; updateUI();
    messageEl.textContent = "";
    if(currentPlayer().startsWith('ai')) setTimeout(aiTakeTurn,500);
  }

  function currentPlayer(){ return players[turnIdx]; }

  function updateUI(){
    turnLabel.textContent=currentPlayer();
    modeLabel.textContent = mode === 'push' ? 'Push' : 'Block';

    // Show a big animated badge for the player's color above the board
    renderPlayerColorBadge();

    playerColorEl.textContent = colors.player;
    ai1ColorEl.textContent = colors.ai1;
    ai2ColorEl.textContent = colors.ai2;
    modePushBtn.classList.toggle('active', mode==='push');
    modeBlockBtn.classList.toggle('active', mode==='block');
  }

  function renderPlayerColorBadge(){
    if (!colors.player) { playerColorIndicator.innerHTML = ""; return; }
    const color = colors.player;
    const label = COLOR_LABELS[color] || color;
    const emoji = COLOR_EMOJIS[color] || "";
    playerColorIndicator.innerHTML = `
      <div class="player-badge-outer">
        <div class="player-badge-inner ${color}">${emoji}</div>
      </div>
      <span class="player-color-label">Your color: <span style="color:${color==='yellow'?'#ffd400':color==='red'?'#ff4444':'#4db6ff'}">${label}</span></span>
    `;
  }

  function updateCounts(){
    const counts={red:0,blue:0,yellow:0,black:0,immovable:0};
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
      const val=board[r][c];
      counts[val]=(counts[val]||0)+1;
    }
    countsEl.innerHTML = `
      <div>Red: ${counts.red}</div>
      <div>Blue: ${counts.blue}</div>
      <div>Yellow: ${counts.yellow}</div>
      <div>Black: ${counts.black}</div>
      <div>Player block in inventory: ${blockInventory.player ? 'Yes' : 'No'}</div>
    `;
  }

  function checkWin(){
    const present=new Set();
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(COLORS.includes(board[r][c])) present.add(board[r][c]);
    if(present.size===1){ messageEl.textContent=`${[...present][0]} wins!`; turnIdx=-1; return true; }
    return false;
  }

  function aiTakeTurn(){
    const me=currentPlayer();

    function aiTryMove(){
      if(blockInventory[me] && Math.random()<0.2){
        const blacks=[]; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(board[r][c]===BLACK) blacks.push([r,c]);
        if(blacks.length){
          const [r,c]=blacks[Math.floor(Math.random()*blacks.length)];
          board[r][c]=IMMOVABLE; immovablePositions[me]=[r,c]; blockInventory[me]=false; immovableColors[me]=colors[me];
          renderGrid(); endTurn(); return;
        }
      }
      let options = [];
      for(let type of ['row','col']){
        for(let idx=0;idx<(type==='row'?ROWS:COLS);idx++){
          for(let dir of [-1,1]){
            let path=[];
            if(type==='row') for(let c=0;c<COLS;c++) path.push([idx,c]);
            else for(let r=0;r<ROWS;r++) path.push([r,idx]);
            if(!path.some(([r,c])=>board[r][c]===IMMOVABLE)) options.push({type,idx,dir});
          }
        }
      }
      if(options.length){
        let pick = options[Math.floor(Math.random()*options.length)];
        pushWithAnimation(pick.type,pick.idx,pick.dir,function(success){
          if(success) endTurn();
          else setTimeout(aiTryMove,100);
        });
      } else {
        endTurn();
      }
    }
    aiTryMove();
  }

  function askColor(){
    const pick=prompt('Choose your color: red, blue, or yellow','red');
    const playerChoice=COLORS.includes(pick)?pick:'red';
    const remaining=COLORS.filter(c=>c!==playerChoice);
    colors={player:playerChoice, ai1:remaining[0], ai2:remaining[1]};
  }

  // Ask for grid size function
  function askGridSize() {
    let size = prompt('Grid size? Enter a number from 4 to 12 (e.g. 7 for 7x7):', '7');
    size = parseInt(size, 10);
    if(isNaN(size) || size < 4 || size > 12) size = 7;
    ROWS = size;
    COLS = size;
  }

  restartBtn.onclick = () => startGame();
  modePushBtn.onclick = () => { mode='push'; updateUI(); };
  modeBlockBtn.onclick = () => { mode='block'; updateUI(); };

  function startGame(){
    askColor();
    askGridSize();
    players=['player','ai1','ai2'];
    turnIdx=0;
    initBoard();
    renderGrid();
    setupEdgeButtons();
    updateUI();
    messageEl.textContent='';
  }

  startGame();
})();
</script>
</body>
</html>