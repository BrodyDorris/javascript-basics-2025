<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raycasting Maze</title>
    <style>
        body {
            background-color: #333;
            color: white;
            font-family: monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #555;
            background-color: #000;
        }
        #instructions {
            margin-top: 20px;
            text-align: center;
        }
        #win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: #4CAF50;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Raycasting Maze Explorer</h1>
    <canvas id="gameCanvas"></canvas>
    <div id="instructions">
        Use W, A, S, D to move and the arrow keys to turn.
    </div>
    <div id="win-message">You Win!</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const winMessage = document.getElementById('win-message');

        canvas.width = 640;
        canvas.height = 480;

        const TILE_SIZE = 64;
        const MAP_WIDTH = 16;
        const MAP_HEIGHT = 16;
        const FOV = 60 * Math.PI / 180; // Field of view in radians
        const NUM_RAYS = canvas.width;
        const MAX_DEPTH = 8 * TILE_SIZE;

        // Maze map (1 = wall, 0 = open space)
        // A simple, hand-coded maze for demonstration.
        // This corrected array defines the maze structure with visible walls.
        const map = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1],
            [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        // Player properties
        const player = {
            x: 2 * TILE_SIZE + TILE_SIZE / 2,
            y: 2 * TILE_SIZE + TILE_SIZE / 2,
            angle: 0,
            speed: 2,
            rotationSpeed: 0.05
        };
        
        // Winning tile coordinates
        const winTile = { x: 14, y: 14 };

        // Keyboard input handling
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        function update() {
            // Forward/backward movement
            if (keys['w']) {
                const moveX = Math.cos(player.angle) * player.speed;
                const moveY = Math.sin(player.angle) * player.speed;
                const newX = player.x + moveX;
                const newY = player.y + moveY;
                if (!isColliding(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys['s']) {
                const moveX = Math.cos(player.angle) * player.speed;
                const moveY = Math.sin(player.angle) * player.speed;
                const newX = player.x - moveX;
                const newY = player.y - moveY;
                if (!isColliding(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }

            // Strafe left/right
            if (keys['a']) {
                const moveX = Math.cos(player.angle - Math.PI / 2) * player.speed;
                const moveY = Math.sin(player.angle - Math.PI / 2) * player.speed;
                const newX = player.x + moveX;
                const newY = player.y + moveY;
                if (!isColliding(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            if (keys['d']) {
                const moveX = Math.cos(player.angle + Math.PI / 2) * player.speed;
                const moveY = Math.sin(player.angle + Math.PI / 2) * player.speed;
                const newX = player.x + moveX;
                const newY = player.y + moveY;
                if (!isColliding(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }

            // Rotation
            if (keys['ArrowLeft']) {
                player.angle -= player.rotationSpeed;
            }
            if (keys['ArrowRight']) {
                player.angle += player.rotationSpeed;
            }
            
            // Check for winning condition
            if (Math.floor(player.x / TILE_SIZE) === winTile.x && Math.floor(player.y / TILE_SIZE) === winTile.y) {
                winMessage.style.display = 'block';
            }
        }

        function isColliding(x, y) {
            const mapX = Math.floor(x / TILE_SIZE);
            const mapY = Math.floor(y / TILE_SIZE);
            return mapX < 0 || mapX >= MAP_WIDTH || mapY < 0 || mapY >= MAP_HEIGHT || map[mapY][mapX] === 1;
        }

        function draw() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw ceiling and floor
            ctx.fillStyle = '#444'; // Ceiling
            ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
            ctx.fillStyle = '#666'; // Floor
            ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

            // Cast rays and draw 3D projection
            for (let i = 0; i < NUM_RAYS; i++) {
                const rayAngle = player.angle - FOV / 2 + (i / NUM_RAYS) * FOV;
                let wallHitDistance = 0;
                let wallType = 0;

                for (let j = 0; j < MAX_DEPTH; j++) {
                    const testX = player.x + Math.cos(rayAngle) * j;
                    const testY = player.y + Math.sin(rayAngle) * j;
                    
                    const mapX = Math.floor(testX / TILE_SIZE);
                    const mapY = Math.floor(testY / TILE_SIZE);

                    if (mapX < 0 || mapX >= MAP_WIDTH || mapY < 0 || mapY >= MAP_HEIGHT || map[mapY][mapX] === 1) {
                        wallHitDistance = j;
                        wallType = map[mapY][mapX]; // Get wall type
                        break;
                    }
                }

                // Fix fisheye effect by correcting for the angle
                const correctedDistance = wallHitDistance * Math.cos(rayAngle - player.angle);

                // Calculate wall height and position
                const wallHeight = (TILE_SIZE * canvas.height) / correctedDistance;
                const wallTop = (canvas.height - wallHeight) / 2;
                const wallBottom = (canvas.height + wallHeight) / 2;

                // Create a darkening effect based on distance
                const shade = 1 - Math.min(correctedDistance / MAX_DEPTH, 1);
                const color = wallType === 1 ? `rgb(${200 * shade}, ${200 * shade}, ${200 * shade})` : `rgb(${255 * shade}, ${255 * shade}, ${255 * shade})`;

                // Color the win tile
                if (Math.floor((player.y + Math.sin(rayAngle) * correctedDistance) / TILE_SIZE) === winTile.y && Math.floor((player.x + Math.cos(rayAngle) * correctedDistance) / TILE_SIZE) === winTile.x) {
                    const winShade = 1 - Math.min(correctedDistance / MAX_DEPTH, 1);
                    const winColor = `rgb(${76 * winShade}, ${175 * winShade}, ${80 * winShade})`; // Green
                    ctx.fillStyle = winColor;
                } else {
                    ctx.fillStyle = color;
                }
                
                // Draw the wall slice
                ctx.beginPath();
                ctx.moveTo(i, wallTop);
                ctx.lineTo(i, wallBottom);
                ctx.stroke();
                ctx.fillRect(i, wallTop, 1, wallHeight);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
